# solution.md 가이드 폼

## 문제 이름과 링크

- [안전지대](https://school.programmers.co.kr/learn/courses/30/lessons/120866)
- Level 0

## 풀이에 관련된 주된 이론

- 구현
- Set 자료구조

## 풀이 방법 (생각의 Flow 방식으로 글 작성)

- 지뢰찾기에서 지뢰가 있는 곳의 주변 8곳 (대각, 십자)을 모두 위험지대라는게 문제의 조건이다.
- 지뢰가 있는 곳을 찾고, 그 주변 8곳을 모두 탐색해야하며, 한번 중복처리를 방지해서 총 위험지대 갯수를 구해야한다.
- 발상의 전환을 했다.
- 원래라면, 주어진 board를 통해 8곳의 경계조건 검사 및 중복처리를 구현해서 갯수를 세야한다.
- 하지만, 새로운 newBoard를 만들어서 주어진 board를 0의 테두리로 감싼다.
- 그리고 실제 board에 해당하는 newBoard의 위치에는 추후 중복처리를 위해 1 ~ n\*n 까지의 정수로 채워 넣엇다.

  | 0   | 0   | 0   | 0   | 0   |
  | --- | --- | --- | --- | --- |
  | 0   | 1   | 2   | 3   | 0   |
  | 0   | 4   | 5   | 6   | 0   |
  | 0   | 7   | 8   | 9   | 0   |
  | 0   | 0   | 0   | 0   | 0   |

- 위의 표를 예시로, [1,1] -> [3,3]을 경계조건 검사 없이 탐색할 수 있다.
- 그리고 [1,1] -> [3,3] 에 해당하는 실제 매개변수로 받은 board에서 검색하여
- 또한 중복처리 방지를 위해 Set 자료구조를 선택하였다.
- 그리고 Set 객체 newBoard의 0이 아닌 실제 정수값들만 add 처리하여 위험지대로 표시하여 갯수를 계산하였다.
- 마지막으로 결과는 전체 board.length 의 제곱에 그 갯수를 빼면 정답이 나온다.

## 어려웠던 이유 (푸는데 어려웠다면 작성)

- 알고리즘 공부 손땐 지 2달, 그래서 2차원 배열 처음에 생성하는것도 익숙하지 않았다.

## 개선 방안 (효율성 테스트 결과가 실패했거나 더 좋은 아이디어가 있을 경우 작성)

- 이번에는 입출력 제한이 1~100 이라서 효율성 테스트를 고려할 것도 없이 삼중포문해도 정답이 나온다.
- 하지만 입출력 제한이 커질 경우 다른 방법을 모색해야할 것 같다.
- 실제로 Queue 자료구조를 통해, 그리고 visited 라는 추가 처리 (방문했냐 안했냐)를 통해 조금 더 멋지게 풀수는 있다.
- 하지만 실제 O(n)은 그것도 마찬가지로 O(8 \* n^2) 일 것이다.
- 그러면 어떻게 이것을 더 줄일 수 있을까? 생각이 안난다. 알고리즘 공부를 너무 쉬었다.
