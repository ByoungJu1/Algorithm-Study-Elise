# solution.md 가이드 폼

## 문제 이름과 링크

- [양궁대회](https://school.programmers.co.kr/learn/courses/30/lessons/92342)
- Level 2

## 풀이에 관련된 주된 이론

- 구현
- 완전탐색
- DFS 백트래킹

## 풀이 방법 (생각의 Flow 방식으로 글 작성)

- DP 냅색 알고리즘으로 풀어야하나 고민했다. 헌데 도저히 구현이 복잡해보여서 다른 방법을 생각해내기로 했다.
- 일단 입력 제한사항에서 n이 10 에서 이런 문제들의 거의 완전탐색 때려박는 문제이다.
- 이것도 말그대로 문제의 조건에 따라 순서대로 따라가며 구현했다.
- 먼저 라이언이 우승하기 위한 조건 중 가장 큰 점수 차 우승을 위해 maxDiff 변수를 선언하고,
- maxDiff를 완전탐색 중 백트래킹방식을 이용하여 보다 큰 값이 있을때 갱신하였다.
- 그리고 그 값일 때의 ryanInfo를 답으로 구하였다.
- 재귀함수 DFS 로직에는 베이스 조건으로 남는 화살수 0 이거나, idx = 11 일때 재귀 호출이 return 되도록 하였다.
- 또한 문제 조건에 따라 getDiff 함수. 즉, ryanInfo와 Info의 리스트에 따른 점수 Diff 계산 함수를 따로 빼내었다.
- 이후로는, 무난한 트리구조의 DFS 그림을 그려 한 level(여기선 idx)가 증가할때는 화살 수를 더하고,
- 다시 한 level 전으로 돌아올때는 화살 수를 빼서, 기존 level에서의 ryanInfo를 복구하는 식으로 로직을 작성했다.
- 만약에 getDiff()로 계산된 diff가 0이거나 음수일 경우에는 아예 result를 갱신하지 못하므로
- 초기 result 값인 `[-1]`이 리턴된다.
- 만약 갱신이 되었다면, 최종 Final 값으로 아래와 같은 값이 리턴된다.

```
[ 0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 0 ]
```

## 어려웠던 이유 (푸는데 어려웠다면 작성)

- 오랜만에 백트래킹을 보다보니 햇갈렸다.
- 문제가 길어서 쳐다보기 싫었지만, 양궁 우승하고 싶어서 풀었다.

## 개선 방안 (효율성 테스트 결과가 실패했거나 더 좋은 아이디어가 있을 경우 작성)

- 초반에 무조건 DP 냅색 문제 계열이라고 생각했는데 구현을 하려니 머리가 복잡해졌는데,
- 완전탐색이 아닌, Dynamic Programming 기법으로 푸는 것도 한번 시도해 볼 필요가 있을 것 같다.
- 하지만 그렇게 푼다고 해도, O(n)에는 영향을 그렇게 끼치지는 않을 것 같다.
- 왜냐하면 이 문제는 결국 무조건 완전탐색하는거랑 비슷한 호출 횟수를 돌것같기 때문이다.
