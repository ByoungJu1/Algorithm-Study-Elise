# solution.md 가이드 폼

## 문제 이름과 링크

- [신고 결과 받기](https://school.programmers.co.kr/learn/courses/30/lessons/92334)
- Level 1

## 풀이에 관련된 주된 이론

- 구현
- Map,Set 자료구조

## 풀이 방법 (생각의 Flow 방식으로 글 작성)

- userId에 따른 reportId들을 리스트로 문제의 조건에 맞게 데이터화시키고,
- 데이터화 된 리스트를 가지고 userId 순서에 맞게 메일을 보내는 final 데이터를 데이터화시켜야 한다.
- 말그대로 문제의 조건에 따라 순서대로 따라가며 구현했다.
- 먼저 빠른 탐색을 위해 Hash 테이블 구조의 Map 자료구조를 선택하여 Table화 했다.
- 추가로 문제에서 주어진 중복신고 카운트 방지를 위해 Set 자료구조를 선택하였다.
- 해시테이블 - reportTable

  | userId | reportId(Set) |
  | ------ | ------------- |
  | muzi   | frodo, neo    |
  | frodo  | neo           |
  | apeach | frodo,muzi    |
  | neo    |               |

- 이 reportTable을 가지고, 문제의 조건에 따라 순서대로 따라가며 데이터화 시켰다.
- reportData (각 유저당 신고 당한 총 횟수)

```
{ frodo: 2, neo: 2, muzi: 1 }
```

- 그리고 이 reportData를 이용하여 문제의 조건에 따라 필터링을 하여 최종 finalReport 데이터를 구했다.
- finalReport (최종 정지 대상자)

```
[ 'frodo', 'neo' ]
```

- 마지막으로 위의 reportTable의 userId 기준으로 finalReport에 있는 정지 대상자를 토대로 메일 횟수글 구했다.
- emailResult (최종 유저당 메일을 받는 횟수)

```
[ 2, 1, 1, 0 ]
```

## 어려웠던 이유 (푸는데 어려웠다면 작성)

- 리액트 하듯이 풀었다..
- 진짜 말그대로 알고리즘적으로 다가가기 보단 컴포넌트, 데이터화, 느낌으로 다가갔는데
- 실제 많은 사람들이 시간초과가 걸렸다는 것을 문제를 풀고 `질문하기` 탭에서 볼수 있었다.

## 개선 방안 (효율성 테스트 결과가 실패했거나 더 좋은 아이디어가 있을 경우 작성)

- Map, Set 구조를 통해 처음부터 접근함으로써 틀리지않고 풀 수 있었지만,
- 실제로 리액트적으로 다가가는게 아닌, 알고리즘적으로 다가가면 2중 포문도 없앨수 있을 것 같다.
- 그리고 reportTable로 부터 reportData를 구하는 과정에서 얕은 복사를 2번이나 했는데
- 이 과정을 하나로 줄이면 좋을 것 같다.
- 또한, 마지막 emailResult을 구하는 과정에서 2중 포문을 사용했는데 이것도 최악의 경우 O(n^2)인데,
- 이것도 O(n)으로 할 수 있는 방법을 생각해봐야겠다.
- 저 2가지가 해결이 되면 실제 코드 동작은 훨씬 더 빨라질 것으로 생각된다.
